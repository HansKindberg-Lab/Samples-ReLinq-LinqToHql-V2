<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--------------------------------------------------------------------------->  
<!--                           INTRODUCTION                                

 The Code Project article submission template (HTML version)

Using this template will help us post your article sooner. To use, just 
follow the 3 easy steps below:
 
     1. Fill in the article description details
     2. Add links to your images and downloads
     3. Include the main article text

That's all there is to it! All formatting will be done by our submission
scripts and style sheets. 

-->  
<!--------------------------------------------------------------------------->  
<!--                        IGNORE THIS SECTION                            -->
<html>
<head>
<title>The Code Project</title>
<Style>
BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
H2 { font-size: 13pt; }
H3 { font-size: 12pt; }
H4 { font-size: 10pt; color: black; }
PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
</style>
<link rel="stylesheet" type="text/css" href="http://www.codeproject.com/App_Themes/NetCommunity/CodeProject.css">
</head>
<body bgcolor="#FFFFFF" color=#000000>
<!--------------------------------------------------------------------------->  


<!-------------------------------     STEP 1      --------------------------->
<!--  Fill in the details (CodeProject will reformat this section for you) -->

<pre>
Title:       Using the re-linq Library To Implement a Linq Provider on the Example of NHibernate
Author:      Markus Giegl 
Email:       author@email.com
Member ID:   12345
Language:    C# 3.0
Platform:    .NET 3.5
Technology:  Linq, NHibernate
Level:       Intermediate
Description: An article on how to use the open source re-linq library to easily implement a powerful Linq provider on the example of Linq to NHibernate.
Section      Suggest a section...
SubSection   Suggest a subsection...
License:     Choose your license (<a href="http://www.gnu.org/licenses/lgpl-3.0.txt">LGPL</a>)
</pre>

<!-------------------------------     STEP 2      --------------------------->
<!--  Include download and sample image information.                       --> 

<ul class=download>
<li><a href="Article_demo.zip">Download re-linq|ing NHibernate demo project - XXX Kb </a></li>
</ul>

<p><img src="remotion.png" alt="re-motion" width=392 height=82></p>


<!-------------------------------     STEP 3      --------------------------->

<!--  Add the article text. Please use simple formatting --> 

<h2>Introduction</h2>

<p>Implementing a Linq provider which supports basic functionality is a fairly easy task. From this one might be led to deduce that implementing a 
full blown Linq provider is also not that hard, neither implementation-logic- nor effort-wise. Unfortunately nothing could be further from the 
truth, which can easily be seen by the lack of availability of non-commercial, above-basic-functionality Linq implementations. 
The <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> developed open source re-motion framework supplies a
commercial class Linq provider library in the form of its re-linq component, which is especially well suited for creating resulting queries
with an SQL/HQL like syntax.
This article shows how one can use re-linq to implement a feature rich Linq provider for the open source NHibernate O/R mapper.
<p>After having read this article and having looked at the accompanying sourcecode, you should have all the information you need to get started on 
implemening an arbitrary Linq provider based on re-linq.


<h2>Why re-linq</h2>

re-linq is a Linq provider library which is especially well suited to transform the tree representation of a Linq query (i.e.
the only representation which is programmatically accessible in .NET) into a SQL (or SQL-like, such as HQL) represenation. Typical 
Linq provider implementations are tree based, which is not well suited to be transformed into SQL-like output
(although not impossible if one is prepared to invest a large amount of effort, as proven by Microsoft's Linq2SQL).

<p>(In addition re-linq is TDD developed open source software. If that doesn't convince you, we don't know what will ;-) )


<h2>Background</h2>

<p>To understand this article you will need to have a basic knowledge of Microsoft <a href="http://en.wikipedia.org/wiki/Linq">Linq</a> technology. 
The article describes how to implement a Linq provider for <a href="http://en.wikipedia.org/wiki/NHibernate">NHibernate</a>, so
it is beneficial if you know the Hibernate Query Language (HQL); however, due to the syntactic similarity of HQL to SQL, the principles
shown in the sample can easily be translated into using re-linq to implement a SQL Linq provider instead (even most of the code would be identical).
<p>Knowing the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor pattern</a> is not required, but might aid in understanding the 
working of re-linq.


<h2>[Setup]</h2>

<p>Before you get started you will need to download and unzip the sample sourcecode. 
Then open to the "DomainObjects.hbm.xml" file in the <code>NHibernate.ReLinq.Sample.UnitTests</code> project and adapt the 
DBMS connection data to your DBMS.
You will als need to create the sample DB given under Catalog="...", which defaults to "NHibernate_ReLinq".

<p>Note that while re-linq is implemented following TDD principles, the sample code is only an intergration test spike 
(It can be a good exercise for someone getting started with TDD to turn the sample spike into a TDD implementation). 

<h2>The Test Domain</h2>
For our tests we use a simple test domain constisting of <code>Location</code>|s, <code>Person</code>|s and <code>PhoneNumber</code>|s.
 Each <code>Person</code> has exactly one <code>Location</code>
and can have an arbitrary number of <code>PhoneNumber</code>|s. You can find the classes in the test project under "DomainObjects", 
the NHibernate mapping
under "Mappings" (Note: You do not need to know how an NHibernate mapping works; suffice to say that that the mapping tells NHibernate 
how to persist instances of our test domain in the DBMS, and how to query them using its SQL-like HQL query language).


<h2>Fast Forward</h2>
If you are an expert and would rather dig into the code right now, here is a quick rundown of how the sample works:
<code>NHQueryFactory</code> creates  <code>NHQueryable&lt;T></code>, the NHibernate specific Linq <code>IQueryable&lt;T></code>.
<code>NHQueryable&lt;T></code> creates and holds a <code>NHQueryExecutor</code>, which forms the bridge between re-linq and 
concrete query provider implementations through its <code>ExecuteScalar&lt;T></code>, <code>ExecuteSingle&lt;T></code> and 
<code>ExecuteCollection&lt;T></code> methods. Here it suffices for <code>ExecuteScalar&lt;T></code> and <code>ExecuteSingle&lt;T></code> 
to simply forward to <code>ExecuteCollection&lt;T></code>; <code>ExecuteCollection&lt;T></code> in turn uses a 
<code>HqlGeneratorQueryModelVisitor</code> to traverse the re-linq <code>QueryModel</code> and retrieve the resulting
HQL query string. 

<p>The <code>HqlGeneratorQueryModelVisitor</code> contains the specific Linq provider code which creates the resulting HQL for the Linq
<code>select</code>, <code>from</code>, <code>where</code>, <code>orderby</code>, <code>join</code>, etc commands through
its <code>VisitSelectClause</code>, <code>VisitWhereClause</code>, etc methods. 
Internally it uses an also Linq provider specific <code>HqlGeneratorExpressionTreeVisitor</code> to process different Linq expressions, such as
binary expressions (<code>Equal</code>, <code>Add</code>,  <code>Multiply</code>,...), member access (<code>person.Location</code>), 
method calls (<code>person.FirstName.Contains("John")</code>), etc through its 
<code>VisitBinaryExpression</code>, <code>VisitMemberExpression</code>,... methods.
These two classes constitute the heart of any specific re-linq based Linq provider.

<p><code>HqlGeneratorQueryModelVisitor</code> internally uses a <code>QueryPartsAggregator</code> to collect multiple <code>from</code>, 
<code>where</code>, etc statements and emit them in the correct HQL order. This is necessary, since Linq is much more flexible than HQL 
(or SQL) with regards to the order of operations. <code>QueryPartsAggregator</code> might be moved to re-linq or the 
<a href="https://svn.re-motion.org/svn/Remotion-Contrib">re-motion contrib library</a> in the future.



<h2>Re-linquing NHibernate</h2>

<h3>select ... from Statement</h3>
After having set up the DB, open the file "IntegrationTests.cs" in <code>NHibernate.ReLinq.Sample.UnitTests</code>. It contains typical NHibernate
setup and teardown code, making sure that the tests do not interfere with each other. Scroll down until you come to the first <code>[Test]</code>,
<code>SelectFrom()</code>.
The test shows the simplest possible Linq query 
<pre>
from pn in NHQueryFactory.Queryable<PhoneNumber> (session) 
select pn;
</pre>
which simply returns all <code>PhoneNumber</code>|s created in the <code>SetupTestData()</code> method.

<p><code>NHQueryFactory</code> is the re-linq NHibernate Linq queryable factory which allows domain objects of the passed generic type to
be queried through Linq; e.g. for <code>PhoneNumber</code> instances:
<pre>NHQueryFactory.Queryable&lt;PhoneNumber></pre>
In the case of NHibernate it has to be passed the <code>NHibernate.ISession</code> to use.

<p>For testing purposes, <code>CreateNHQuery(session, query.Expression).QueryString</code> gives the HQL query string 
corresponding to the Linq <code>query</code>, which equals 
<pre>"select pn from NHibernate.ReLinq.Sample.UnitTests.DomainObjects.PhoneNumber as pn"</pre>
Executing the <code>query</code> directly gives all 5 <code>PhoneNumber</code>|s in the test domain, as expected.

<p>The implementation shows that re-linq does most of the work for us. All we have to do is override <code>VisitMainFromClause</code> and 
<code>VisitSelectClause</code> in <code>HqlGeneratorQueryModelVisitor</code> (which derives from re-linq's <code>QueryModelVisitorBase</code>), with
the following trivial implementation. 
<pre>
public override void VisitMainFromClause (MainFromClause fromClause, QueryModel queryModel)
{
  _queryParts.AddFromPart (fromClause);
  base.VisitMainFromClause (fromClause, queryModel);
}

public override void VisitSelectClause (SelectClause selectClause, QueryModel queryModel)
{
  _queryParts.SelectPart = GetHqlExpression (selectClause.Selector);
  base.VisitSelectClause (selectClause, queryModel);
}
</pre>
All the work is done <code>QueryParts</code>, a simple helper class, which collects together 
different query components of the same type
(e.g. <code>from</code>-statements) and emits them in the correct order at the end.

<p>
In the case of the <code>from</code>-statement, he also handles emission of the correct HQL alias syntax:
<pre>
public void AddFromPart (IQuerySource querySource)
{
  FromParts.Add (string.Format ("{0} as {1}", GetEntityName (querySource), querySource.ItemName));
}
</pre>
Note that this is easy to do, since re-linq already supplies us with the information we need.



<h3>where Statement</h3>

The next test introduces the <code>select</code>-statement and the binary equality comparison operator:

<pre>
from pn in NHQueryFactory.Queryable<PhoneNumber> (session)
  where pn.CountryCode == "11111"
  select pn;
</pre>

The implementation is as straightforward as above:
<pre>
public override void VisitSelectClause (SelectClause selectClause, QueryModel queryModel)
{
  _queryParts.SelectPart = GetHqlExpression (selectClause.Selector);
  base.VisitSelectClause (selectClause, queryModel);
}
</pre>

<code>GetHqlExpression</code> uses a <code>HqlGeneratorExpressionTreeVisitor</code> (which derives from re-linq's 
<code>ThrowingExpressionTreeVisitor</code>, aptly named since he throws when he encounters an expression for which no
handler has been implemented.), which handles e.g. binary expression evaluation; in the case of the equality operator:

<pre>
protected override Expression VisitBinaryExpression (BinaryExpression expression)
{
  _hqlExpression.Append ("(");
  VisitExpression (expression.Left);

  switch (expression.NodeType)
  {
    case ExpressionType.Equal:
      _hqlExpression.Append (" = ");
      break;

    // handle additional binary expressions

    default:
      base.VisitBinaryExpression (expression); // throws
      break;
  }

  VisitExpression (expression.Right);
  _hqlExpression.Append (")");

  return expression;
}
</pre>
(Note: In production code using a lookup table instead of the switch-case-construct will be the better choice).
<p>The <code>VisitExpression</code> method call is executed by re-linq code and does the required traversal of data structures.





<h3>Binary Expressions</h3>

Since re-linq is already SQL/HQL-friendly, binary expressions can all be handled as trivially as equals:
<pre>
    case ExpressionType.Equal:
      _hqlExpression.Append (" = ");
      break;

    case ExpressionType.AndAlso:
    case ExpressionType.And:
      _hqlExpression.Append (" and ");
      break;
    
    case ExpressionType.OrElse:
    case ExpressionType.Or:
      _hqlExpression.Append (" or ");
      break;

    case ExpressionType.Add:
      _hqlExpression.Append (" + ");
      break;

    case ExpressionType.Subtract:
      _hqlExpression.Append (" - ");
      break;

    // etc...
</pre>


<h3>join Clause</h3>
Implementing <code>join</code>-operations also takes only a few lines of code: 
<pre>
public override void VisitJoinClause (JoinClause joinClause, QueryModel queryModel, int index)
{
  _queryParts.AddFromPart (joinClause);
  _queryParts.AddWherePart (
      "({0} = {1})",
      GetHqlExpression (joinClause.OuterKeySelector), 
      GetHqlExpression (joinClause.InnerKeySelector));

  base.VisitJoinClause (joinClause, queryModel, index);
}
</pre>
Where again the <code>VisitJoinClause</code> call is executed by re-linq.


<h3>Method Calls</h3>

The following shows the implementation of a method call, in this case the test whether a string contains the given substring; the 
call to <code>Contains</code> is transformed into the SQL/HQL "<code>like %</code>&lt;substring><code>%</code>" syntax:
<pre>
protected override Expression VisitMethodCallExpression (MethodCallExpression expression)
{
  var supportedMethod = typeof (string).GetMethod ("Contains");
  if (expression.Method.Equals (supportedMethod))
  {
    _hqlExpression.Append ("(");
    VisitExpression (expression.Object);
    _hqlExpression.Append (" like '%'+");
    VisitExpression (expression.Arguments[0]);
    _hqlExpression.Append ("+'%')");
    return expression;
  }
  else
  {
    return base.VisitMethodCallExpression (expression); // throws
  }
}
</pre>

<h3>The Rest</h3>
The examples above are about as complex as it gets. For further exploration please have a look at the demo project (download link at top of page).


<h2>[Teardown]</h2>
In this article we have shown how the <a href="http://www.re-motion.org/">re-motion</a> re-linq Linq provider library can be used to easily
implement Linq to SQL-like languages conversions, by successive overriding of methods in two <code>HqlGeneratorQueryModelVisitor</code> and
<code>HqlGeneratorExpressionTreeVisitor</code> visitor classes. 

May all your tests be green.
Cleanup();
// Ma;-)rkus


<h2>History</h2>
<ul>
<li>2009.08.05 - Initial posting.
</ul>

<!-------------------------------    That's it!   --------------------------->
</body>

</html>
